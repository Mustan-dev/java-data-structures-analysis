# ⚙️ Java Data Structures & Algorithmic Analysis
![Java](https://img.shields.io/badge/Java-17+-yellow.svg)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)
![Status: Completed](https://img.shields.io/badge/Status-Completed-brightgreen)

## 📘 Project Overview

This repository showcases a comprehensive study of core data structures and algorithmic principles using Java. It blends theoretical foundations with practical implementations, performance analysis, and rigorous testing — designed for academic excellence, technical interviews, and real-world system design.

Each module is structured to demonstrate clarity, scalability, and efficiency, with code written to reflect best practices in object-oriented programming and algorithmic thinking.

---

## 🧠 Objectives

- Implement foundational data structures in Java
- Analyze time and space complexity using Big O notation
- Apply generic programming and recursion where appropriate
- Validate functionality through targeted unit tests
- Compare performance trade-offs across implementations

---

## 📁 Directory Structure

| Folder Name                          | Description                                                                 |
|--------------------------------------|-----------------------------------------------------------------------------|
| `Task1_B Java Code`                  | Java code examples with annotated complexity analysis                       |
| `Task 1_C`                           | Theoretical breakdown of algorithmic performance using Big O notation       |
| `Task2_And Testing various scenarios`| Stack implementation with `getMin()` optimization and edge-case testing     |
| `Task3`                              | Advanced structures: Linked Lists, Binary Search Trees, Graphs              |
| `Task4`                              | Java Collections: HashMap and ArrayList usage with performance comparison   |

---

## 🔍 Key Concepts

### Task 1: Algorithm Complexity
- Big O notation: O(1), O(n), O(log n), O(n²), O(2ⁿ)
- Time vs Space complexity
- Code walkthroughs with performance annotations

### Task 2: Stack Implementation
- LIFO principle
- Dual-stack `getMin()` design (O(1) time)
- Generic stack with `<T extends Comparable<T>>`
- Unit testing: duplicates, edge cases, empty states

### Task 3: Advanced Data Structures
- Singly & Doubly Linked Lists
- Binary Search Tree (BST): insert, search, delete, traversal
- Graph representation via adjacency matrix
- Applications: LRU cache, auto-suggestion, network mapping

### Task 4: Java Collections
- HashMap: key-value operations, constant-time access
- ArrayList: indexed storage, filtering with Iterator
- Time complexity comparison: HashMap vs list-based mapping
- Use cases: caching, indexing, session tracking

---

## 🧪 Testing Strategy

Each implementation is validated through targeted test cases:
- Functional correctness
- Edge case handling
- Console output verification
- Performance sensitivity

---

## 🚀 Getting Started

1. Clone the repository:
   ```bash
   git clone https://github.com/Mustan-dev/java-data-structures-analysis
   cd java-data-analysis 
   
---

## 📖 License

This project is licensed under the [MIT License](LICENSE) and is intended for educational and portfolio use.

---

## 👨‍💻 Author

**Mustan**   
GitHub: [github.com/Mustan-dev](https://github.com/Mustan-dev)  
